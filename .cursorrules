Habit tracking application 
### Core Principles

1. **Clean Architecture**
- Domain Layer: Pure business logic, no external dependencies
- Application Layer: Use cases and orchestration
- Infrastructure Layer: External dependencies and implementations

2. **Hexagonal Architecture**
- Ports and Adapters pattern for flexibility
   - Port: Interface for external services (in, out)
   - Adapter: Implementation of the port

3. **CQRS**
- Commands modify state and return void/success/failure
   - `UI -> Command -> Use Case -> Domain -> Save -> (Optional) Emit Events`
- Queries return data but don't modify state
   - `UI -> Query -> Use Case -> Repository -> Return Data`

4. **Event-Driven Components**
- Core operations handled synchronously
- Events used for non-critical features

4.a **Event Publishing**
- Domain layer defines events
- Application layer coordinates publishing through EventBus port
- Infrastructure layer implements actual event distribution

4.b **Event Handling**
- Feature-specific handlers in application layer
- Global handlers for cross-cutting concerns


### Project Structure

```
app/                                # Entry point
│   └── (tabs)/                     # navigation
src/
├── domain/                         # Business Invariants
│   ├── habit/                      
│   │   ├── aggregate.ts            # Aggregate Root
│   │   ├── entities/
│   │   ├── services/
│   │   ├── value-objects/
│   │   ├── types.ts
│   │   └── events.ts               # Domain Events
│   └── shared/                     
│
├── application/                    
│   ├── habit/                      # Feature module
│   │   ├── ports/                 
│   │   │   ├── in/                 # Driving ports
│   │   │   │   ├── commands/      
│   │   │   │   └── queries/       
│   │   │   └── out/                # Driven ports
│   │   │       └── Repository.ts  
│   │   │
│   │   ├── use-cases/              # Use case implementations
│   │   │   ├── CreateHabit.ts
│   │   │   ├── EditHabit.ts
│   │   │   └── GetHabitStats.ts
│   │   └── event-handlers/         # Feature-specific handlers
│   │       ├── StreakHandler.ts
│   │       └── NotificationHandler.ts
│   │
│   ├── shared/                     # Cross-cutting concerns
│   │   │   └── ports/
│   │   │       └── EventBus.ts
│   │   └── event-handlers/         # Global event handlers
│   │       └── AnalyticsHandler.ts
│   └── App.ts                      # Application setup
│
└── infrastructure/                 # External concerns & implementations
    ├── habit/
    │   └── SQLHabitRepository.ts
    └── shared/
        └── InMemoryEventBus.ts
```

### Best Practices

1. **Domain Logic**
- Keep domain logic in domain layer
- Use value objects for validation
- Raise domain events for significant changes

2. **Use Cases**
- One primary operation per use case
- Handle orchestration of domain objects
- Manage transactions when needed
- Publish events for side effects

3. **Event Handling**
- Keep event handlers focused
- Handle failures gracefully
- Log events for debugging
- Don't depend on event order

4. **Adapters**
- Implement one port per adapter
- Keep adapters thin
- Handle external service errors
- Convert between domain and external models

### Common Pitfalls to Avoid

- Don't bypass ports for direct access
- Avoid business logic in adapters
- Don't make domain depend on external concerns
